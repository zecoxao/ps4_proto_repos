#include <stdbool.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <kernel.h>
#include <libdbg.h>
#include <sceerror.h>
#include <scetypes.h>
#include <net.h>
#include <libhttp.h>

int run;

struct filedesc {
	void *useless1[3];
	void *fd_rdir;
	void *fd_jdir;
};

struct proc {
	char useless[64];
	struct ucred *p_ucred;
	struct filedesc *p_fd;
};

struct thread {
	void *useless;
	struct proc *td_proc;
};

struct auditinfo_addr {
	char useless[184];
};

struct ucred {
	uint32_t useless1;
	uint32_t cr_uid;     // effective user id
	uint32_t cr_ruid;    // real user id
	uint32_t useless2;
	uint32_t useless3;
	uint32_t cr_rgid;    // real group id
	uint32_t useless4;
	void *useless5;
	void *useless6;
	void *cr_prison;     // jail(2)
	void *useless7;
	uint32_t useless8;
	void *useless9[2];
	void *useless10;
	struct auditinfo_addr useless11;
	uint32_t *cr_groups; // groups
	uint32_t useless12;
};

uint64_t __readmsr(unsigned long __register)
{
	unsigned long __edx;
	unsigned long __eax;
	__asm__("rdmsr" : "=d"(__edx), "=a"(__eax) : "c"(__register));
	return (((uint64_t)__edx) << 32) | (uint64_t)__eax;
}

#define X86_CR0_WP (1 << 16)
uint64_t cr0;

static inline __attribute__((always_inline)) uint64_t readCr0(void)
{
	__asm__ volatile ("movq %0, %%cr0" : "=r" (cr0) : : "memory");
	return cr0;
}

static inline __attribute__((always_inline)) void writeCr0(uint64_t cr0)
{
	__asm__ volatile("movq %%cr0, %0" : : "r" (cr0) : "memory");
}

int khax(struct thread* td, uint64_t* uap) {

	uint32_t SMC_LM32_DEBA = 0x80000334;
	uint32_t SMC_LM32_BP0 = 0x80000338;
	uint32_t SMC_PC_C = 0x80000370;
	uint32_t COMM_ADRC = 0x3fe80;
	uint32_t COMM_DATA = 0x3fe84;


	size_t(*kprintf)(const char* fmt, ...) = (void*)0xFFFFFFFF824CE1A0ULL;


	uint32_t(*CailGetSmcIndReg) (uint32_t unk, uint32_t index) = (void*)0xFFFFFFFF826C32E0ULL;
	uint32_t(*CailSetSmcIndReg) (uint32_t unk, uint32_t index, uint32_t val) = (void*)0xFFFFFFFF826C3300ULL;

	kprintf("clear communication addr&control\n");
	CailSetSmcIndReg(0, COMM_ADRC, 0);
	kprintf("communication addr&control:%08X", CailGetSmcIndReg(0, COMM_ADRC));
	kprintf("set debug vector (debug exception = base + 0x20)\n");
	CailSetSmcIndReg(0, SMC_LM32_DEBA, 0x3f100);
	kprintf("debug vector %08X\n", CailGetSmcIndReg(0, SMC_LM32_DEBA));

	kprintf("load shellcode\n");

	CailSetSmcIndReg(0, 0x3f120, 0x98000000);
	CailSetSmcIndReg(0, 0x3f124, 0x78010003);
	CailSetSmcIndReg(0, 0x3f128, 0x3821fe80);
	CailSetSmcIndReg(0, 0x3f12c, 0x28220000);
	CailSetSmcIndReg(0, 0x3f130, 0x20430001);
	CailSetSmcIndReg(0, 0x3f134, 0x4460fffb);
	CailSetSmcIndReg(0, 0x3f138, 0x3442ffff);
	CailSetSmcIndReg(0, 0x3f13c, 0x28420000);
	CailSetSmcIndReg(0, 0x3f140, 0x34240004);
	CailSetSmcIndReg(0, 0x3f144, 0x58820000);
	CailSetSmcIndReg(0, 0x3f148, 0x58200000);
	CailSetSmcIndReg(0, 0x3f14c, 0xe3fffff5);

	int i = 0;
	for (i = 0x3F120; i < 0x3F150; i = i + 4) {
		kprintf("%08X\n", CailGetSmcIndReg(0, i));
	}

	kprintf("get random PC value\n");

	kprintf("random PC value: %08X\n", CailGetSmcIndReg(0, SMC_PC_C));

	uint32_t sample_pc = CailGetSmcIndReg(0, SMC_PC_C);
	CailSetSmcIndReg(0, SMC_LM32_BP0, sample_pc | 1);

	kprintf("random PC value: %08X\n", CailGetSmcIndReg(0, SMC_PC_C));

	kprintf("return to userland\n");

	return 0;
}



/* Main entry point of program*/
SceInt32 main(int argc, const char *const argv[])
{

	printf("jailbreaking\n");

	syscall(11, khax);
}